
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">data-processing/docs/docs.go (0.0%)</option>
				
				<option value="file1">data-processing/internal/delivery/http/handler.go (0.0%)</option>
				
				<option value="file2">data-processing/internal/domain/mocks.go (0.0%)</option>
				
				<option value="file3">data-processing/internal/repository/gorm_repository.go (100.0%)</option>
				
				<option value="file4">data-processing/internal/usecase/csv_processor.go (33.7%)</option>
				
				<option value="file5">data-processing/main.go (0.0%)</option>
				
				<option value="file6">data-processing/pkg/csv/reader.go (0.0%)</option>
				
				<option value="file7">data-processing/pkg/database/postgres.go (0.0%)</option>
				
				<option value="file8">data-processing/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/csv/process": {
            "post": {
                "description": "Insert / Update Process CSV",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "csv"
                ],
                "summary": "Process CSV",
                "parameters": [
                    {
                        "description": "Array Path CSV",
                        "name": "csv",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ProcessCSVRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handler.ProcessCSVRequest": {
            "type": "object",
            "required": [
                "file_paths"
            ],
            "properties": {
                "file_paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Data Process API",
        Description:      "Data Process Service",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// ============================================
// internal/delivery/http/handler.go
// ============================================
package handler

import (
        "net/http"

        "data-processing/internal/domain"

        "github.com/gin-gonic/gin"

        _ "data-processing/docs"

        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

type Handler struct {
        usecase domain.CSVProcessorUsecase
}

func NewHandler(usecase domain.CSVProcessorUsecase) *Handler <span class="cov0" title="0">{
        return &amp;Handler{usecase: usecase}
}</span>

func (h *Handler) RegisterRoutes(r *gin.Engine) <span class="cov0" title="0">{
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        api := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                api.POST("/csv/process", h.ProcessCSV)
        }</span>
}

type ProcessCSVRequest struct {
        FilePaths []string `json:"file_paths" binding:"required"`
}

// @BasePath /api/v1

// @Summary Process CSV
// @Description Insert / Update Process CSV
// @Tags csv
// @Accept json
// @Produce json
// @Param csv body ProcessCSVRequest true "Array Path CSV"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Router /csv/process [post]
func (h *Handler) ProcessCSV(c *gin.Context) <span class="cov0" title="0">{
        var req ProcessCSVRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Channel for progress updates (optional for WebSocket in future)
        <span class="cov0" title="0">progressChan := make(chan *domain.ProgressUpdate, 100)

        // Close progress channel when done
        defer close(progressChan)

        // Process in background and collect progress
        go func() </span><span class="cov0" title="0">{
                for progress := range progressChan </span><span class="cov0" title="0">{
                        // In production, send via WebSocket or SSE
                        _ = progress
                }</span>
        }()

        <span class="cov0" title="0">result, err := h.usecase.ProcessCSVFiles(req.FilePaths, progressChan)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "CSV files processed successfully",
                "result":  result,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        mock "github.com/stretchr/testify/mock"
)

// NewMockProductRepository creates a new instance of MockProductRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProductRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockProductRepository <span class="cov0" title="0">{
        mock := &amp;MockProductRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockProductRepository is an autogenerated mock type for the ProductRepository type
type MockProductRepository struct {
        mock.Mock
}

type MockProductRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockProductRepository) EXPECT() *MockProductRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockProductRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// BulkUpsert provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) BulkUpsert(products []*Product) error <span class="cov0" title="0">{
        ret := _mock.Called(products)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BulkUpsert")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func([]*Product) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(products)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductRepository_BulkUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkUpsert'
type MockProductRepository_BulkUpsert_Call struct {
        *mock.Call
}

// BulkUpsert is a helper method to define mock.On call
//   - products []*Product
func (_e *MockProductRepository_Expecter) BulkUpsert(products interface{}) *MockProductRepository_BulkUpsert_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_BulkUpsert_Call{Call: _e.mock.On("BulkUpsert", products)}
}</span>

func (_c *MockProductRepository_BulkUpsert_Call) Run(run func(products []*Product)) *MockProductRepository_BulkUpsert_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 []*Product
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].([]*Product)
                }</span>
                <span class="cov0" title="0">run(
                        arg0,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_BulkUpsert_Call) Return(err error) *MockProductRepository_BulkUpsert_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductRepository_BulkUpsert_Call) RunAndReturn(run func(products []*Product) error) *MockProductRepository_BulkUpsert_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Create provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) Create(product *Product) error <span class="cov0" title="0">{
        ret := _mock.Called(product)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(*Product) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(product)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProductRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - product *Product
func (_e *MockProductRepository_Expecter) Create(product interface{}) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_Create_Call{Call: _e.mock.On("Create", product)}
}</span>

func (_c *MockProductRepository_Create_Call) Run(run func(product *Product)) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 *Product
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(*Product)
                }</span>
                <span class="cov0" title="0">run(
                        arg0,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_Create_Call) Return(err error) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductRepository_Create_Call) RunAndReturn(run func(product *Product) error) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindById provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) FindById(id int) (*Product, error) <span class="cov0" title="0">{
        ret := _mock.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindById")</span>
        }

        <span class="cov0" title="0">var r0 *Product
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(int) (*Product, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(id)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(int) *Product); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*Product)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(int) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepository_FindById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindById'
type MockProductRepository_FindById_Call struct {
        *mock.Call
}

// FindById is a helper method to define mock.On call
//   - id int
func (_e *MockProductRepository_Expecter) FindById(id interface{}) *MockProductRepository_FindById_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_FindById_Call{Call: _e.mock.On("FindById", id)}
}</span>

func (_c *MockProductRepository_FindById_Call) Run(run func(id int)) *MockProductRepository_FindById_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 int
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(int)
                }</span>
                <span class="cov0" title="0">run(
                        arg0,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_FindById_Call) Return(product *Product, err error) *MockProductRepository_FindById_Call <span class="cov0" title="0">{
        _c.Call.Return(product, err)
        return _c
}</span>

func (_c *MockProductRepository_FindById_Call) RunAndReturn(run func(id int) (*Product, error)) *MockProductRepository_FindById_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAll provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) GetAll() ([]*Product, error) <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAll")</span>
        }

        <span class="cov0" title="0">var r0 []*Product
        var r1 error
        if returnFunc, ok := ret.Get(0).(func() ([]*Product, error)); ok </span><span class="cov0" title="0">{
                return returnFunc()
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func() []*Product); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*Product)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepository_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockProductRepository_GetAll_Call struct {
        *mock.Call
}

// GetAll is a helper method to define mock.On call
func (_e *MockProductRepository_Expecter) GetAll() *MockProductRepository_GetAll_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_GetAll_Call{Call: _e.mock.On("GetAll")}
}</span>

func (_c *MockProductRepository_GetAll_Call) Run(run func()) *MockProductRepository_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_GetAll_Call) Return(products []*Product, err error) *MockProductRepository_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(products, err)
        return _c
}</span>

func (_c *MockProductRepository_GetAll_Call) RunAndReturn(run func() ([]*Product, error)) *MockProductRepository_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) Update(product *Product) error <span class="cov0" title="0">{
        ret := _mock.Called(product)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(*Product) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(product)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockProductRepository_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - product *Product
func (_e *MockProductRepository_Expecter) Update(product interface{}) *MockProductRepository_Update_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_Update_Call{Call: _e.mock.On("Update", product)}
}</span>

func (_c *MockProductRepository_Update_Call) Run(run func(product *Product)) *MockProductRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 *Product
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(*Product)
                }</span>
                <span class="cov0" title="0">run(
                        arg0,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_Update_Call) Return(err error) *MockProductRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductRepository_Update_Call) RunAndReturn(run func(product *Product) error) *MockProductRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockLogger creates a new instance of MockLogger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLogger(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockLogger <span class="cov0" title="0">{
        mock := &amp;MockLogger{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockLogger is an autogenerated mock type for the Logger type
type MockLogger struct {
        mock.Mock
}

type MockLogger_Expecter struct {
        mock *mock.Mock
}

func (_m *MockLogger) EXPECT() *MockLogger_Expecter <span class="cov0" title="0">{
        return &amp;MockLogger_Expecter{mock: &amp;_m.Mock}
}</span>

// Debug provides a mock function for the type MockLogger
func (_mock *MockLogger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                _mock.Called(format, args)
        }</span> else<span class="cov0" title="0"> {
                _mock.Called(format)
        }</span>

        <span class="cov0" title="0">return</span>
}

// MockLogger_Debug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debug'
type MockLogger_Debug_Call struct {
        *mock.Call
}

// Debug is a helper method to define mock.On call
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Debug(format interface{}, args ...interface{}) *MockLogger_Debug_Call <span class="cov0" title="0">{
        return &amp;MockLogger_Debug_Call{Call: _e.mock.On("Debug",
                append([]interface{}{format}, args...)...)}
}</span>

func (_c *MockLogger_Debug_Call) Run(run func(format string, args ...interface{})) *MockLogger_Debug_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 string
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(string)
                }</span>
                <span class="cov0" title="0">var arg1 []interface{}
                var variadicArgs []interface{}
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        variadicArgs = args[1].([]interface{})
                }</span>
                <span class="cov0" title="0">arg1 = variadicArgs
                run(
                        arg0,
                        arg1...,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockLogger_Debug_Call) Return() *MockLogger_Debug_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockLogger_Debug_Call) RunAndReturn(run func(format string, args ...interface{})) *MockLogger_Debug_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Error provides a mock function for the type MockLogger
func (_mock *MockLogger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                _mock.Called(format, args)
        }</span> else<span class="cov0" title="0"> {
                _mock.Called(format)
        }</span>

        <span class="cov0" title="0">return</span>
}

// MockLogger_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type MockLogger_Error_Call struct {
        *mock.Call
}

// Error is a helper method to define mock.On call
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Error(format interface{}, args ...interface{}) *MockLogger_Error_Call <span class="cov0" title="0">{
        return &amp;MockLogger_Error_Call{Call: _e.mock.On("Error",
                append([]interface{}{format}, args...)...)}
}</span>

func (_c *MockLogger_Error_Call) Run(run func(format string, args ...interface{})) *MockLogger_Error_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 string
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(string)
                }</span>
                <span class="cov0" title="0">var arg1 []interface{}
                var variadicArgs []interface{}
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        variadicArgs = args[1].([]interface{})
                }</span>
                <span class="cov0" title="0">arg1 = variadicArgs
                run(
                        arg0,
                        arg1...,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockLogger_Error_Call) Return() *MockLogger_Error_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockLogger_Error_Call) RunAndReturn(run func(format string, args ...interface{})) *MockLogger_Error_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Info provides a mock function for the type MockLogger
func (_mock *MockLogger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                _mock.Called(format, args)
        }</span> else<span class="cov0" title="0"> {
                _mock.Called(format)
        }</span>

        <span class="cov0" title="0">return</span>
}

// MockLogger_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockLogger_Info_Call struct {
        *mock.Call
}

// Info is a helper method to define mock.On call
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Info(format interface{}, args ...interface{}) *MockLogger_Info_Call <span class="cov0" title="0">{
        return &amp;MockLogger_Info_Call{Call: _e.mock.On("Info",
                append([]interface{}{format}, args...)...)}
}</span>

func (_c *MockLogger_Info_Call) Run(run func(format string, args ...interface{})) *MockLogger_Info_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 string
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(string)
                }</span>
                <span class="cov0" title="0">var arg1 []interface{}
                var variadicArgs []interface{}
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        variadicArgs = args[1].([]interface{})
                }</span>
                <span class="cov0" title="0">arg1 = variadicArgs
                run(
                        arg0,
                        arg1...,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockLogger_Info_Call) Return() *MockLogger_Info_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockLogger_Info_Call) RunAndReturn(run func(format string, args ...interface{})) *MockLogger_Info_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Progress provides a mock function for the type MockLogger
func (_mock *MockLogger) Progress(filePath string, processed int, total int, percentage float64) <span class="cov0" title="0">{
        _mock.Called(filePath, processed, total, percentage)
        return
}</span>

// MockLogger_Progress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Progress'
type MockLogger_Progress_Call struct {
        *mock.Call
}

// Progress is a helper method to define mock.On call
//   - filePath string
//   - processed int
//   - total int
//   - percentage float64
func (_e *MockLogger_Expecter) Progress(filePath interface{}, processed interface{}, total interface{}, percentage interface{}) *MockLogger_Progress_Call <span class="cov0" title="0">{
        return &amp;MockLogger_Progress_Call{Call: _e.mock.On("Progress", filePath, processed, total, percentage)}
}</span>

func (_c *MockLogger_Progress_Call) Run(run func(filePath string, processed int, total int, percentage float64)) *MockLogger_Progress_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                var arg0 string
                if args[0] != nil </span><span class="cov0" title="0">{
                        arg0 = args[0].(string)
                }</span>
                <span class="cov0" title="0">var arg1 int
                if args[1] != nil </span><span class="cov0" title="0">{
                        arg1 = args[1].(int)
                }</span>
                <span class="cov0" title="0">var arg2 int
                if args[2] != nil </span><span class="cov0" title="0">{
                        arg2 = args[2].(int)
                }</span>
                <span class="cov0" title="0">var arg3 float64
                if args[3] != nil </span><span class="cov0" title="0">{
                        arg3 = args[3].(float64)
                }</span>
                <span class="cov0" title="0">run(
                        arg0,
                        arg1,
                        arg2,
                        arg3,
                )</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockLogger_Progress_Call) Return() *MockLogger_Progress_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockLogger_Progress_Call) RunAndReturn(run func(filePath string, processed int, total int, percentage float64)) *MockLogger_Progress_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// ============================================
// internal/repository/gorm_repository.go
// ============================================
package repository

import (
        "data-processing/internal/domain"
        "errors"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type gormRepository struct {
        db *gorm.DB
}

func NewGormRepository(db *gorm.DB) domain.ProductRepository <span class="cov10" title="14">{
        return &amp;gormRepository{db: db}
}</span>

func (r *gormRepository) Create(product *domain.Product) error <span class="cov3" title="2">{
        return r.db.Create(product).Error
}</span>

func (r *gormRepository) Update(product *domain.Product) error <span class="cov3" title="2">{
        return r.db.Save(product).Error
}</span>

func (r *gormRepository) FindById(id int) (*domain.Product, error) <span class="cov4" title="3">{
        var product domain.Product
        err := r.db.Where("id = ?", id).First(&amp;product).Error
        if err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov1" title="1">return &amp;product, nil</span>
}

func (r *gormRepository) BulkUpsert(products []*domain.Product) error <span class="cov4" title="3">{
        if len(products) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">return r.db.Clauses(clause.OnConflict{
                Columns: []clause.Column{{Name: "id"}},
                DoUpdates: clause.AssignmentColumns([]string{
                        "name", "brand", "category", "price", "currency", "stock", "ean", "color", "size", "availability", "internal_id", "updated_at"}),
        }).CreateInBatches(&amp;products, 100).Error</span>
}

func (r *gormRepository) GetAll() ([]*domain.Product, error) <span class="cov4" title="3">{
        var products []*domain.Product
        err := r.db.Find(&amp;products).Error
        return products, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// ============================================
// internal/usecase/csv_processor.go
// ============================================
package usecase

import (
        "data-processing/internal/domain"
        "data-processing/pkg/csv"
        "fmt"
        "strconv"
        "sync"
        "time"
)

type csvProcessorUsecase struct {
        repo        domain.ProductRepository
        logger      domain.Logger
        csvReader   *csv.Reader
        workerCount int
        batchSize   int
}

func NewCSVProcessorUsecase(
        repo domain.ProductRepository,
        logger domain.Logger,
        workerCount int,
        batchSize int,
) domain.CSVProcessorUsecase <span class="cov1" title="1">{
        return &amp;csvProcessorUsecase{
                repo:        repo,
                logger:      logger,
                csvReader:   csv.NewReader(),
                workerCount: workerCount,
                batchSize:   batchSize,
        }
}</span>

func (u *csvProcessorUsecase) ProcessCSVFiles(
        filePaths []string,
        progressChan chan&lt;- *domain.ProgressUpdate,
) (*domain.FinalResult, error) <span class="cov0" title="0">{
        start := time.Now()
        u.logger.Info("Starting CSV processing with %d workers", u.workerCount)

        finalResult := &amp;domain.FinalResult{
                FileResults: make(map[string]*domain.FileResult),
        }

        // Process each file
        for _, filePath := range filePaths </span><span class="cov0" title="0">{
                u.logger.Info("Processing file: %s", filePath)

                fileResult, err := u.processFileWithWorkers(filePath, progressChan)
                if err != nil </span><span class="cov0" title="0">{
                        u.logger.Error("Failed to process file %s: %v", filePath, err)
                        finalResult.Errors = append(finalResult.Errors, fmt.Sprintf("File %s: %v", filePath, err))
                        continue</span>
                }

                <span class="cov0" title="0">finalResult.FileResults[filePath] = fileResult
                finalResult.TotalRecords += fileResult.TotalRecords
                finalResult.Inserted += fileResult.Inserted
                finalResult.Updated += fileResult.Updated
                finalResult.Failed += fileResult.Failed
                finalResult.Errors = append(finalResult.Errors, fileResult.Errors...)</span>
        }

        <span class="cov0" title="0">finalResult.ProcessingTime = time.Since(start)
        u.logger.Info("Processing completed in %v", finalResult.ProcessingTime)
        u.logger.Info("Total: %d | Inserted: %d | Updated: %d | Failed: %d",
                finalResult.TotalRecords, finalResult.Inserted, finalResult.Updated, finalResult.Failed)

        return finalResult, nil</span>
}

func (u *csvProcessorUsecase) processFileWithWorkers(
        filePath string,
        progressChan chan&lt;- *domain.ProgressUpdate,
) (*domain.FileResult, error) <span class="cov0" title="0">{
        // Read CSV file
        records, err := u.csvReader.ReadCSV(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalRecords := len(records)
        u.logger.Info("File %s: Found %d records", filePath, totalRecords)

        // Create channels
        jobChan := make(chan *domain.ProcessJob, totalRecords)
        resultChan := make(chan *domain.ProcessResult, totalRecords)

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; u.workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go u.worker(i+1, jobChan, resultChan, &amp;wg)
        }</span>

        // Send jobs to workers
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, record := range records </span><span class="cov0" title="0">{
                        jobChan &lt;- &amp;domain.ProcessJob{
                                Record:   record,
                                FilePath: filePath,
                        }
                }</span>
                <span class="cov0" title="0">close(jobChan)</span>
        }()

        // Close workers
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(resultChan)
        }</span>()

        // Collect results and send progress updates
        <span class="cov0" title="0">fileResult := &amp;domain.FileResult{
                TotalRecords: totalRecords,
        }

        processedCount := 0
        batch := make([]*domain.Product, 0, u.batchSize)

        for result := range resultChan </span><span class="cov0" title="0">{
                processedCount++

                if result.Error != nil </span><span class="cov0" title="0">{
                        fileResult.Failed++
                        errorMsg := fmt.Sprintf("Row %d (SKU: %s): %v",
                                result.RowNumber, result.Product.Name, result.Error)
                        fileResult.Errors = append(fileResult.Errors, errorMsg)
                        u.logger.Error(errorMsg)
                }</span> else<span class="cov0" title="0"> {
                        if result.IsUpdate </span><span class="cov0" title="0">{
                                fileResult.Updated++
                        }</span> else<span class="cov0" title="0"> {
                                fileResult.Inserted++
                        }</span>
                        <span class="cov0" title="0">batch = append(batch, result.Product)

                        // Batch upsert
                        if len(batch) &gt;= u.batchSize </span><span class="cov0" title="0">{
                                if err := u.repo.BulkUpsert(batch); err != nil </span><span class="cov0" title="0">{
                                        u.logger.Error("Batch upsert failed: %v", err)
                                }</span>
                                <span class="cov0" title="0">batch = batch[:0]</span>
                        }
                }

                // Send progress update every 10 records or at completion
                <span class="cov0" title="0">if processedCount%10 == 0 || processedCount == totalRecords </span><span class="cov0" title="0">{
                        percentage := float64(processedCount) / float64(totalRecords) * 100
                        u.logger.Progress(filePath, processedCount, totalRecords, percentage)

                        if progressChan != nil </span><span class="cov0" title="0">{
                                progressChan &lt;- &amp;domain.ProgressUpdate{
                                        FileName:       filePath,
                                        TotalRecords:   totalRecords,
                                        ProcessedCount: processedCount,
                                        Percentage:     percentage,
                                        Inserted:       fileResult.Inserted,
                                        Updated:        fileResult.Updated,
                                        Failed:         fileResult.Failed,
                                        Message:        fmt.Sprintf("Processing %s: %.2f%% complete", filePath, percentage),
                                }
                        }</span>
                }
        }

        // Final batch upsert
        <span class="cov0" title="0">if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                if err := u.repo.BulkUpsert(batch); err != nil </span><span class="cov0" title="0">{
                        u.logger.Error("Final batch upsert failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return fileResult, nil</span>
}

func (u *csvProcessorUsecase) worker(
        id int,
        jobs &lt;-chan *domain.ProcessJob,
        results chan&lt;- *domain.ProcessResult,
        wg *sync.WaitGroup,
) <span class="cov1" title="1">{
        defer wg.Done()

        for job := range jobs </span><span class="cov3" title="2">{
                result := u.processRecord(job)
                results &lt;- result
        }</span>
}

func (u *csvProcessorUsecase) processRecord(job *domain.ProcessJob) *domain.ProcessResult <span class="cov7" title="6">{
        record := job.Record

        // Convert CSV record to Product
        product, err := u.convertToProduct(record)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;domain.ProcessResult{
                        Product:   product,
                        Error:     err,
                        RowNumber: record.RowNumber,
                        FilePath:  job.FilePath,
                }
        }</span>

        // Check if product exists
        <span class="cov6" title="5">existing, err := u.repo.FindById(product.ID)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;domain.ProcessResult{
                        Product:   product,
                        Error:     err,
                        RowNumber: record.RowNumber,
                        FilePath:  job.FilePath,
                }
        }</span>

        <span class="cov6" title="4">isUpdate := false
        if existing != nil </span><span class="cov1" title="1">{
                product.ID = existing.ID
                product.CreatedAt = existing.CreatedAt
                isUpdate = true
        }</span>

        <span class="cov6" title="4">return &amp;domain.ProcessResult{
                Product:   product,
                IsUpdate:  isUpdate,
                RowNumber: record.RowNumber,
                FilePath:  job.FilePath,
        }</span>
}

func (u *csvProcessorUsecase) convertToProduct(record *domain.CSVRecord) (*domain.Product, error) <span class="cov10" title="12">{
        price, err := strconv.ParseFloat(record.Price, 64)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid price: %v", err)
        }</span>

        <span class="cov9" title="10">stock, err := strconv.Atoi(record.Stock)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid stock: %v", err)
        }</span>

        <span class="cov8" title="9">id, err := strconv.Atoi(record.ID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid stock: %v", err)
        }</span>

        <span class="cov8" title="8">internalId, err := strconv.Atoi(record.InternalId)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid stock: %v", err)
        }</span>

        <span class="cov8" title="7">if record.Name == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("SKU and Name are required")
        }</span>

        <span class="cov7" title="6">return &amp;domain.Product{
                ID:           id,
                Name:         record.Name,
                Description:  record.Description,
                Brand:        record.Brand,
                Category:     record.Category,
                Currency:     record.Currency,
                Ean:          record.Ean,
                Color:        record.Color,
                Size:         record.Size,
                Availability: record.Availability,
                InternalId:   internalId,
                Price:        price,
                Stock:        stock,
                CreatedBy:    "system",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// ============================================
// cmd/api/main.go
// ============================================
package main

import (
        "log"

        "data-processing/config"
        handler "data-processing/internal/delivery/http"
        "data-processing/internal/repository"
        "data-processing/internal/usecase"
        "data-processing/pkg/database"
        "data-processing/pkg/logger"

        "github.com/gin-gonic/gin"
)

// @title Data Process API
// @version 1.0
// @description Data Process Service
func main() <span class="cov0" title="0">{
        cfg := config.LoadConfig()

        appLogger := logger.NewLogger()

        db, err := database.NewPostgresDB(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect database: %v", err)
        }</span>

        <span class="cov0" title="0">repo := repository.NewGormRepository(db)
        uc := usecase.NewCSVProcessorUsecase(repo, appLogger, cfg.WorkerCount, cfg.BatchSize)
        handler := handler.NewHandler(uc)

        r := gin.Default()
        handler.RegisterRoutes(r)

        log.Printf("Server starting on port %s with %d workers", cfg.ServerPort, cfg.WorkerCount)
        if err := r.Run(":" + cfg.ServerPort); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// ============================================
// pkg/csv/reader.go
// ============================================
package csv

import (
        "data-processing/internal/domain"
        "encoding/csv"
        "log"
        "os"
)

type Reader struct{}

func NewReader() *Reader <span class="cov0" title="0">{
        return &amp;Reader{}
}</span>

func (r *Reader) ReadCSV(filePath string) ([]*domain.CSVRecord, error) <span class="cov0" title="0">{
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">file, err := os.Open(currentDir + filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var csvRecords []*domain.CSVRecord
        // Skip header row
        for i, record := range records </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if len(record) &lt; 5 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">csvRecords = append(csvRecords, &amp;domain.CSVRecord{
                        ID:           record[0],
                        Name:         record[1],
                        Description:  record[2],
                        Brand:        record[3],
                        Category:     record[4],
                        Price:        record[5],
                        Currency:     record[6],
                        Stock:        record[7],
                        Ean:          record[8],
                        Color:        record[9],
                        Size:         record[10],
                        Availability: record[11],
                        InternalId:   record[12],
                        RowNumber:    i + 1,
                })</span>
        }

        <span class="cov0" title="0">return csvRecords, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// ============================================
// pkg/database/postgres.go
// ============================================
package database

import (
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func NewPostgresDB(dsn string) (*gorm.DB, error) <span class="cov0" title="0">{
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// ============================================
// pkg/logger/logger.go
// ============================================
package logger

import (
        "log"
        "time"
)

type AppLogger struct{}

func NewLogger() *AppLogger <span class="cov0" title="0">{
        return &amp;AppLogger{}
}</span>

func (l *AppLogger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        log.Printf("[INFO] "+format, args...)
}</span>

func (l *AppLogger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        log.Printf("[ERROR] "+format, args...)
}</span>

func (l *AppLogger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        log.Printf("[DEBUG] "+format, args...)
}</span>

func (l *AppLogger) Progress(filePath string, processed, total int, percentage float64) <span class="cov0" title="0">{
        timestamp := time.Now().Format("15:04:05")
        log.Printf("[PROGRESS] [%s] %s: %d/%d (%.2f%%)",
                timestamp, filePath, processed, total, percentage)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
